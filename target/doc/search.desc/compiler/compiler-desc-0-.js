searchState.loadedDescShard("compiler", 0, "This program reads a C4 source file, tokenizes it using …\nAddition operator (e.g., a + b)\nAddress-of operator (e.g., &amp;x)\nLogical AND operator (e.g., a &amp;&amp; b)\nArray type (e.g., int[3])\nAn array index expression (e.g., arr[0])\nAn array literal (e.g., {1, 2, 3})\nAssignment operator (e.g., a = b)\nAssignment statement (e.g., x = 42;)\nRepresents the different binary operators in the language. …\nBinary operation (e.g., a + b)\nBitwise AND operator (e.g., a &amp; b)\nBitwise OR operator (e.g., a | b)\nBitwise XOR operator (e.g., a ^ b)\nBlock of statements (e.g., { … })\nA boolean literal (e.g., true or false)\nType casting (e.g., (int)x)\nA character literal (e.g., ‘a’)\nCharacter type\nDereference operator (e.g., *x)\nDivision operator (e.g., a / b)\nEnum value (e.g., EnumName.Variant)\nEquality operator (e.g., a == b)\nAbstract Syntax Tree (AST) for a simple programming …\nExpression statement (e.g., x = 42;)\nFunction definition (e.g., function foo() { … })\nFunction call (e.g., my_function(arg1, arg2))\nGreater than or equal operator (e.g., a &gt;= b)\nGreater than operator (e.g., a &gt; b)\nIf statement (e.g., if (x &gt; 0) { … } else { … })\nInteger value\nInteger type\nLess than or equal operator (e.g., a &lt;= b)\nLess than operator (e.g., a &lt; b)\nVariable declaration (e.g., let x = 42;)\nModulus operator (e.g., a % b)\nMultiplication operator (e.g., a * b)\nLogical NOT operator (e.g., !x)\nInequality operator (e.g., a != b)\nA numeric literal (e.g., 42)\nLogical OR operator (e.g., a || b)\nPointer type (e.g., int* or char*)\nPost-decrement operation (e.g., x–)\nPost-increment operation (e.g., x++)\nPre-decrement operation (e.g., –x)\nPre-increment operation (e.g., ++x)\nPrint statement (e.g., print(“Hello”);)\nReturn statement (e.g., return 42;)\nBitwise left shift operator (e.g., a &lt;&lt; b)\nBitwise right shift operator (e.g., a &gt;&gt; b)\nSizeOf operator to get the size of a type\nRepresents the different types of statements in the …\nString value\nA string literal (e.g., “Hello”)\nSubtraction operator (e.g., a - b)\nTernary conditional expression (e.g., condition ? then : …\nRepresents the different types in the language.\nRepresents the different unary operators in the language.\nUnary operation (e.g., !x)\nRepresents runtime values (integers and strings).\nA variable reference (e.g., x)\nVoid type (for functions that do not return a value)\nWhile loop (e.g., while (x &gt; 0) { … })\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLexer that tokenizes the input code.\nRepresents the types of tokens the lexer can generate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new Lexer instance.\nReturns the next token in the input.\nThe <code>Parser</code> struct is responsible for parsing the input …\nParses a block of statements (enclosed in <code>{}</code>).\nExpects an identifier and advances the parser, or panics …\nExpects a specific token and advances the parser, or …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Parser</code> instance. Initializes the parser, …\nAdvances to the next token in the input.\nParses the entire input and returns a vector of statements.\nParses addition and subtraction expressions (e.g., <code>+</code>, <code>-</code>).\nParses assignment expressions (variable assignments or …\nParses bitwise AND expressions (using <code>&amp;</code>).\nParses bitwise OR expressions (using <code>|</code>).\nParses bitwise XOR expressions (using <code>^</code>).\nParses comparison expressions (e.g., <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>).\nParses logical AND expressions (using <code>&amp;&amp;</code>).\nParses logical OR expressions (using <code>||</code>).\nParses multiplication, division, and modulus expressions …\nHandles postfix operations (e.g., <code>++</code>, <code>--</code>).\nParses primary expressions (e.g., numbers, strings, …\nParses shift expressions (e.g., <code>&lt;&lt;</code>, <code>&gt;&gt;</code>).\nParses a type (e.g., <code>int</code>, <code>char</code>, <code>void</code>).\nParses unary operations (e.g., negation, dereference, …\nParses a single statement from the input. It handles …\nArray value, which contains a vector of <code>Value</code>s.\nRepresents a function in the language, including its name, …\nInteger value (e.g., 42)\nString value (e.g., “Hello”)\nRepresents the different values that can be used at …\nThe virtual machine (VM) that runs the program, holding …\nThe body of the function, represented as a statement.\nA map of constant names to their corresponding constant …\nEvaluates an expression and returns its result as a …\nEvaluates an expression and returns its result as a <code>Value</code>.\nExecutes a statement, performing the appropriate actions …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA map of function names to their corresponding function …\nRetrieves the last result as an integer.\nRetrieves the last result as a string.\nHandles assignment operations for variables and array …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe last result returned by an expression evaluation.\nThe name of the function.\nCreates a new instance of the virtual machine with …\nA list of parameter names for the function.\nThe return type of the function, which may be <code>None</code> for …\nSets the last result to a given value and sets the return …\nA flag that indicates whether the VM should return after …\nThe list of variable scopes, with each scope being a map …")