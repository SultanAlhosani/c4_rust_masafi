use crate::ast::{Expr, Stmt};
use crate::lexer::{Lexer, Token};
use crate::vm::Vm;

/// The `Parser` is responsible for converting a stream of tokens into an
/// abstract syntax tree (AST).
///
/// It processes the tokens generated by the lexer and organizes them into
/// meaningful structures like expressions and statements.
pub struct Parser<'a> {
    lexer: Lexer,
    current_token: Token,
    vm: &'a mut Vm,
}

impl<'a> Parser<'a> {
    /// Creates a new `Parser` instance.
    ///
    /// # Parameters
    /// - `lexer`: The `Lexer` instance providing the tokens.
    /// - `vm`: A mutable reference to the virtual machine (VM) for function handling.
    ///
    /// # Returns
    /// A new `Parser` instance.
    pub fn new(lexer: Lexer, vm: &'a mut Vm) -> Self {
        let mut parser = Self {
            lexer,
            current_token: Token::Eof, // Placeholder
            vm,
        };
        parser.next(); // Load the first token
        parser
    }

    /// Advances to the next token in the input.
    pub fn next(&mut self) {
        self.current_token = self.lexer.next_token();
    }

    /// Parses the entire input into a list of statements.
    ///
    /// # Returns
    /// A vector of `Stmt` representing the parsed statements.
    pub fn parse(&mut self) -> Vec<Stmt> {
        let mut statements = Vec::new();
        while self.current_token != Token::Eof {
            statements.push(self.statement());
        }
        statements
    }

    /// Parses a single statement from the input.
    ///
    /// # Returns
    /// A `Stmt` representing the parsed statement.
    fn statement(&mut self) -> Stmt {
        match &self.current_token {
            Token::Return => {
                self.next();
                let expr = self.expression();
                if self.current_token == Token::Semicolon {
                    self.next();
                }
                Stmt::Return(expr)
            }
            Token::Let => {
                self.next();
                let name = match &self.current_token {
                    Token::Identifier(n) => {
                        let n = n.clone();
                        self.next();
                        n
                    }
                    _ => panic!("Expected identifier after 'let'"),
                };
                if self.current_token != Token::Assign {
                    panic!("Expected '=' after identifier");
                }
                self.next();
                let value = self.expression();
                if self.current_token == Token::Semicolon {
                    self.next();
                }
                Stmt::Let { name, value }
            }
            Token::Identifier(name) => {
                let var_name = name.clone();
                self.next();
                if self.current_token != Token::Assign {
                    panic!("Expected '=' after identifier");
                }
                self.next();
                let value = self.expression();
                if self.current_token == Token::Semicolon {
                    self.next();
                }
                Stmt::Assign {
                    name: var_name,
                    value,
                }
            }
            Token::If => {
                self.next();
                if self.current_token != Token::OpenParen {
                    panic!("Expected '(' after 'if'");
                }
                self.next();
                let condition = self.expression();
                if self.current_token != Token::CloseParen {
                    panic!("Expected ')' after condition");
                }
                self.next();
                let then_branch = Box::new(self.statement());
                let else_branch = if self.current_token == Token::Else {
                    self.next();
                    Some(Box::new(self.statement()))
                } else {
                    None
                };
                Stmt::If {
                    condition,
                    then_branch,
                    else_branch,
                }
            }
            Token::While => {
                self.next();
                if self.current_token != Token::OpenParen {
                    panic!("Expected '(' after 'while'");
                }
                self.next();
                let condition = self.expression();
                if self.current_token != Token::CloseParen {
                    panic!("Expected ')' after condition");
                }
                self.next();
                let body = Box::new(self.statement());
                Stmt::While { condition, body }
            }
            Token::OpenBrace => self.block(),
            Token::Fn => {
                self.next(); // Consume 'fn'

                // Expect an identifier (function name)
                let name = match &self.current_token {
                    Token::Identifier(n) => {
                        let n = n.clone();
                        self.next();
                        n
                    }
                    _ => panic!("Expected function name after 'fn'"),
                };

                // Parse parameters
                if self.current_token != Token::OpenParen {
                    panic!("Expected '(' after function name");
                }
                self.next(); // Consume '('

                let mut params = Vec::new();
                while self.current_token != Token::CloseParen {
                    if let Token::Identifier(param) = &self.current_token {
                        params.push(param.clone());
                        self.next();

                        if self.current_token == Token::Comma {
                            self.next(); // Consume ','
                        } else if self.current_token != Token::CloseParen {
                            panic!("Expected ',' or ')' in parameter list");
                        }
                    } else {
                        panic!("Expected parameter name");
                    }
                }
                self.next(); // Consume ')'

                // Parse function body (block)
                let body = Box::new(self.block());

                Stmt::Function { name, params, body }
            }
            _ => panic!(
                "Unexpected token: {:?}. Ensure the input is valid.",
                self.current_token
            ),
        }
    }

    /// Parses an expression from the input.
    ///
    /// # Returns
    /// An `Expr` representing the parsed expression.
    fn expression(&mut self) -> Expr {
        self.parse_expr()
    }

    /// Parses an expression, delegating to comparison operators.
    ///
    /// # Returns
    /// An `Expr` representing the parsed expression.
    fn parse_expr(&mut self) -> Expr {
        self.parse_cmp()
    }

    /// Parses comparison operators (==, !=, <, >), delegating to addition/subtraction.
    ///
    /// # Returns
    /// An `Expr` representing the parsed expression.
    fn parse_cmp(&mut self) -> Expr {
        let mut lhs = self.parse_add_sub();

        while matches!(
            self.current_token,
            Token::Equal | Token::NotEqual | Token::LessThan | Token::GreaterThan
        ) {
            let op = match self.current_token {
                Token::Equal => crate::ast::BinOp::Equal,
                Token::NotEqual => crate::ast::BinOp::NotEqual,
                Token::LessThan => crate::ast::BinOp::LessThan,
                Token::GreaterThan => crate::ast::BinOp::GreaterThan,
                _ => unreachable!(),
            };
            self.next(); // Consume the operator
            let rhs = self.parse_add_sub();
            lhs = Expr::BinaryOp {
                op,
                left: Box::new(lhs),
                right: Box::new(rhs),
            };
        }

        lhs
    }

    /// Parses addition and subtraction (+, -), delegating to multiplication/division.
    ///
    /// # Returns
    /// An `Expr` representing the parsed expression.
    fn parse_add_sub(&mut self) -> Expr {
        let mut lhs = self.parse_mul_div();

        while matches!(self.current_token, Token::Add | Token::Sub) {
            let op = match self.current_token {
                Token::Add => crate::ast::BinOp::Add,
                Token::Sub => crate::ast::BinOp::Sub,
                _ => unreachable!(),
            };
            self.next(); // Consume the operator
            let rhs = self.parse_mul_div();
            lhs = Expr::BinaryOp {
                op,
                left: Box::new(lhs),
                right: Box::new(rhs),
            };
        }

        lhs
    }

    /// Parses multiplication, division, and modulo (*, /, %), delegating to primary expressions.
    ///
    /// # Returns
    /// An `Expr` representing the parsed expression.
    fn parse_mul_div(&mut self) -> Expr {
        let mut lhs = self.parse_primary();

        while matches!(self.current_token, Token::Mul | Token::Div) {
            let op = match self.current_token {
                Token::Mul => crate::ast::BinOp::Mul,
                Token::Div => crate::ast::BinOp::Div,
                _ => unreachable!(),
            };
            self.next(); // Consume the operator
            let rhs = self.parse_primary();
            lhs = Expr::BinaryOp {
                op,
                left: Box::new(lhs),
                right: Box::new(rhs),
            };
        }

        lhs
    }

    /// Parses primary expressions, such as literals, variables, function calls, and parenthesized expressions.
    ///
    /// # Returns
    /// An `Expr` representing the parsed primary expression.
    fn parse_primary(&mut self) -> Expr {
        match &self.current_token {
            Token::Num(n) => {
                let val = *n;
                self.next();
                Expr::Number(val)
            }
            Token::True => {
                self.next();
                Expr::Boolean(true)
            }
            Token::False => {
                self.next();
                Expr::Boolean(false)
            }
            Token::Char(c) => {
                let ch = *c;
                self.next();
                Expr::Char(ch)
            }
            Token::Identifier(name) => {
                let var_name = name.clone();
                self.next();

                // Check if this is a function call
                if self.current_token == Token::OpenParen {
                    self.next(); // Consume '('
                    let mut args = Vec::new();

                    while self.current_token != Token::CloseParen {
                        args.push(self.expression());
                        if self.current_token == Token::Comma {
                            self.next(); // Consume ','
                        } else if self.current_token != Token::CloseParen {
                            panic!("Expected ',' or ')' in function call");
                        }
                    }
                    self.next(); // Consume ')'

                    Expr::FunctionCall {
                        name: var_name,
                        args,
                    }
                } else {
                    Expr::Variable(var_name)
                }
            }
            Token::OpenParen => {
                self.next(); // Consume '('
                let expr = self.expression();
                if self.current_token != Token::CloseParen {
                    panic!("Expected ')' after expression");
                }
                self.next(); // Consume ')'
                expr
            }
            _ => panic!(
                "Unexpected token in primary expression: {:?}",
                self.current_token
            ),
        }
    }

    /// Parses a block of statements enclosed in braces `{}`.
    ///
    /// # Returns
    /// A `Stmt::Block` containing the parsed statements.
    fn block(&mut self) -> Stmt {
        if self.current_token != Token::OpenBrace {
            return self.statement();
        }

        self.next();
        let mut statements = Vec::new();

        while self.current_token != Token::CloseBrace {
            statements.push(self.statement());
        }

        self.next();

        Stmt::Block(statements)
    }
}
